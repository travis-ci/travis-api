#!/usr/bin/env ruby

$LOAD_PATH << File.expand_path('../../lib', __FILE__)
$stdout.sync = true

require 'bundler/setup'

require 'active_record'
# To silence deprecation warning
ActiveRecord::Base.raise_in_transactional_callbacks = true

require 'date'
require 'stringio'
require 'thread'
require 'travis'
require 'travis/api/v3/github'
require 'travis/config/defaults'
require 'travis/model/repository'

module Travis::API::V3
  class GitHub
    def delete_webhook(repo)
      if url = webhook_url?(repo)
        info("Deleting webhook repo=%s" % [repo.slug])
        gh.delete(url)
      end
    end
  end
end


# Temp redirect of output
def silence(&block)
  previous_stdout, $stdout = $stdout, StringIO.new
  previous_stderr, $stderr = $stderr, StringIO.new
  block.call
ensure
  $stdout = previous_stdout
  $stderr = previous_stderr
end

class DeleteHooks
  def self.setup_db!
    # Setup connection
    config = Travis::Config.load.database.to_h.merge(pool: 5)
    ActiveRecord::Base.establish_connection(config)

    # Allow a longer than default timeout to account for heavy queries
    ActiveRecord::Base.connection.execute "SET statement_timeout = 180000"
  end

  def self.clear_active_db_connections!
    ActiveRecord::Base.clear_active_connections!
  end

  attr_accessor :query, :num_workers

  def initialize(query, num_workers: 5)
    @query, @num_workers = query, num_workers
  end

  def call
    did_not_migrate = []
    queue = Queue.new

    # Populate queue with all ids from query
    ids = query.ids
    ids.sort.reverse.each { |id| queue.push(id) }
    puts "Queued #{ids.size} repos"

    sleep 1

    # Start num_workers threads and start running off the queue
    workers = (0...num_workers).map do
      Thread.new do
        while !queue.empty? do
          begin
            repo = Repository.find(queue.pop)
            delete_hook(repo) if repo
          rescue ThreadError => e
            puts "Thread error"
            raise e
          ensure
            self.class.clear_active_db_connections!
          end
        end
      end
    end

    workers.map(&:join)
  end

  def delete_hook(repo)
    puts "Attempting to delete hook for repo #{repo.slug}"

    # Get admin permissions for repo
    admin_permissions = repo.permissions.where(admin: true).joins(:user).where("users.github_oauth_token IS NOT NULL")
    # Loop through admin users until one is able to perform the migration
    admin_permissions.each do |ap|
      gh = Travis::API::V3::GitHub.new(ap.user)

      begin
        service_hook = gh.service_hook(repo)
        webhook = gh.webhook(repo)

        # If there are no hooks, mark repo as inactive and move on
        if !service_hook && !webhook
          puts "No hooks at all for #{repo.slug}"
        end

        # Check for webhook and make sure that active attr matches on our side
        if webhook
          puts "Webhook found, syncing repo #{repo.slug} active attr"
          gh.delete_webhook(repo)
        end
        if service_hook
          gh.deactivate_service_hook(repo)
        end

        # Only set webhook for repos with an active service hook
        if (service_hook && service_hook['active'])
          puts "Found active service hook for #{repo.slug}, setting webhook"
          gh.set_hook(repo, true)
        end

        migrated = true
        break
      rescue => e
        puts "Error migrating #{repo.slug} using oauth token from #{ap.user.login}"
        puts e.message
        puts "Trying next admin user..."
        next
      end
    end
  end
end

module Query
  class ForBase
    attr_accessor :id

    def initialize(id)
      @id = id
    end
  end

  class ForRepo < ForBase
    def call
      Repository.where("id = #{id}")
    end
  end

  class ForUser < ForBase
    def call
      puts "Querying all repos for user"
      Repository.where("owner_id = #{id} and owner_type = 'User' ")
    end
  end

  class ForOrganization < ForBase
    def call
      puts "Querying all repos for organization"
      Repository.where("owner_id = #{id} and owner_type = 'Organization' ")
    end
  end
end
type = ARGV.first
id = ARGV.second
puts "#{type} #{id}"
if type && id
  case type
  when 'repository', 'repo'
    query = Query::ForRepo.new(id.to_i)
  when 'user'
    query = Query::ForUser.new(id.to_i)
  when 'organization', 'org'
    query = Query::ForOrganization.new(id.to_i)
  end
end

silence do
  DeleteHooks.setup_db!
end
DeleteHooks.new(query.call).call if query

